# 数据结构

## 排序算法

### 冒泡排序

冒泡排序是通过不断地交换相邻两个元素的位置进行比较的算法，具体实现如下

```python
def bubbleSort(L ):
    # 外面的这层循环是用来控制总共需要几轮，第一次循环需要n-1轮以后的依次递减
    for i in range(0,len(L)-1):
        # 内层循环的作用主要是用来进行判断每轮前后两个数大小是否一致
        for j in range(0,len(L) - i - 1):
            if L[j] > L[j+ 1] :
                temp = L[j]
                L[j] = L[j+1]
                L[j+1] = temp
    return L
```

### 插入排序

插入排序主要是将待排序序列分成两部分，前半部分有序，后半部分无序，每次将无序数列中的元素按需要插入到待排序数列之中

```python
def insertSort(arr):
    # 从第二个元素依次向后遍历
    for i in range(1, len(arr)):
        key = arr[i] # 一开始假设第二个元素就是需要插入的
        j = i-1 # j是i前面的一个元素
       # 如满足以下这个条件,将arr[j+1]的值赋值给arr[j]
        # 并且将j的位置向前移动
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        # 循环结束之后，将key的值赋值给arr[j+1]
        arr[j+1] = key
    return arr
```

### 选择排序

主要思想是从待排序的序列之中选择最小的元素插入到已经排好序的序列之中

```python
def selectSort(arr):
    for i in range(0, len(arr)-1):
        # 默认第一个元素就是最小的
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[j] < arr[min_index]:
                min_index = j
        # 循环结束之后交换i与minindex的值
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return  arr
```

### 归并排序

主要是想是分治法以及递归,首先,将问题分成几个不同的子问题,然后分别对子问题进行求解，首先是在merge_sort里面将数组按照一定的规则分成两部分，然后分别对两部分进行继续分解，最后再将分开的子问题合并进行求解。可以在merge函数里面实现对不同数组的合并。

```python
def merge_sort(arr):
    #如果序列只有一个元素,直接返回
    if len(arr) == 1:
        return arr
    # 作为问题分解的切分点,按照这个分法就可以将原问题分解成两个不同的子问题
    mid = int(len(arr) / 2)
    # 递归解决序列的坐班部分
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    # 这个时候左右两部分已经有序,然后将其合并
    return merge(left,right)

# 这个函数的主要作用是完成子问题的合并
def merge(left,right):
    # 12, 13,11, 5, 6主要是将这个函数的左右两部分进行合并
    i = 0 # 左指针,用来移动左边的元素
    j = 0 # 右指针用来移动右边数组元素
    result = [] # 新的数组用来存放左边和右边比较出来的数据
    # 如果i和j都没有走到各自的尽头,那么需要分开进行比较
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i]) 
            i += 1
        else:
            result.append(right[j])
            j += 1
    # 退出循环的时候,说明i和j两个指针有一方已经走到了尽头,
    # 所以,将两个数组的剩余部分分别加入到result数组之后        
    result += list(left[i:])
    result += list(right[j:])        
    return result
```

### 快速排序

快速排序也是基于分治法以及递归的，他的主要思想是通过通过每次遍历找到基准值的下标，然后依次递归的对基准值左右两部分的数据进行处理的算法，主要的实现思路如下：

- 选出一个key,一般是最左边或是最右边的。
- 定义一个begin和一个end,begin从左向右走,end从右向左走。(需要注意的是:若选择最左边的数据作为key,则需要end先走;
- 若选择最右边的数据作为key,则需要bengin先走)。
- 在走的过程中,若end遇到小于key的数,则停下,begin开始走,直到begin遇到一个大于key的数时,将begin和right的内容交换,end再次开始走,如此进行下去,
- 直到begin和end最终相遇,此时将相遇点的内容与key交换即可。(选取最左边的值作为key)
- 此时key的左边都是小于key的数,key的右边都是大于key的数
- 将key的左序列和右序列再次进行这种单趟排序,如此反复操作下去,直到左右序列只有一个数据,或是左右序列不存在时,便停止操作,此时此部分已有序

代码如下

```python
def quickSort(arr, start, end):
    if start >= end:
        return
    l = start # 左指针，用来移动数组左边的元素
    r = end   # 有指正，用来移动数组右边的元素
    key = arr[start]
   # 如果满足这个条件，说明没有走到尽头，继续移动
    while l < r : 
        while key <= arr[r] and l < r:
            r -= 1
        while key >= arr[l] and l < r:
            l += 1
        # 如果不满足上述两个循环，说明l和r所指向的数值与key的大小是有说法的，
        # 将他们两个所指的元素进行交换    
        if l < r:    
            arr[l], arr[r] = arr[r], arr[l]
    # 如果退出大的循环，说明l和j已经相遇，并且他们所在的位置就是我们要找的基准值的位置，
    # 将其与key的位置进行交换
    arr[start], arr[l] = arr[l], arr[start]   
    # 然后递归的调用快速排序算法分别对数组的做优两个部分进行交换
    	quickSort(arr, start, l - 1)
    	quickSort(arr, l + 1, end)      
    return arr        
```

### 堆排序

堆排序首先需要建立一个大根堆，构建方式为，首先自顶向下依次寻找是否每个节点都满足大根堆，不是的话依次递归替换主要思路如下：

- 首先是对待排序序列进行构建大根堆，大根堆的要求是父节点必须大于子节点，递归的对序列进行调整
- 构建完大根堆之后根节点一定是最大的，将其与最后一个节点进行交换，然后剔除最后一个节点，对剩余的所有节点重新进行构建大根堆，
- 然后同上面一步递归的进行处理，直到所有的节点都处理完毕，程序结束，退出循环。

```python
"""
arr 待构建的数组
n 数组的大小
i 待维护的元素
"""
def heapify(arr,n , i):
    # 首先假设第一个元素是最大的
    largest = i
    lson = i * 2 + 1
    rson = i * 2 + 2
    # 然后判断左右孩子节点是否满足要求,不满足进行交换
    if lson < n and arr[lson] > arr[largest]:
        largest = lson
    if rson < n and arr[rson] > arr[largest]:
        largest = rson
    # 然后判断largest的下标是否满足要求，如果不是，重新替换掉largest的值
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        # 然后在地递归的检查新构成的树是否满足要求
        heapify(arr, n, largest)
    return arr
# 对数组进行堆排序首先将数组进行建立大根堆，建立完成之后将首位元素互换，最大的数值被替换到最后面，然后

# 继续对剩下的元素依次进行堆排序
def heapsort(arr):
    arrlen = len(arr)
    # 第一次建立大根堆，从后往前依次调整
    for i in range(arrlen // 2-1,-1,-1):
        heapify(arr, arrlen, i)
    # 执行堆排序
    for i in range(arrlen - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # 交换当前堆顶元素与末尾元素
        heapify(arr, i, 0)  # 重新调整堆
    return  arr
```

### 计数排序

计数排序的思路：根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；对额外空间内数据进行计算，得出每一个元素的正确位置；将待排序集合每一个元素移动到计算得出的正确位置上。

![1720335655832](D:\ruanjian\Typora\1720335655832.png)

```python
def count(arr):
   # 第一步是确定最大元素与最小元素的差值，确定新数组的范围
    min_arr = arr[0]
    max_arr = arr[len(arr)-1]
    for i in range(len(arr)):
        if arr[i] < min_arr:
           min_arr = arr[i]
        if arr[i] > max_arr:
            max_arr = arr[i]
    # print(min_arr,"\t",max_arr)
    # 找到了最大元素以及最小元素，下一步就是通过他两的差值确定额外空间的大小
    newArr_size = max_arr - min_arr + 1
    newArr = [0] * newArr_size
    print(len(newArr))
    # 计数每个元素的出现次数
    for i in range(len(arr)):
        # print("===",i)
        newArr[arr[i]-min_arr] += 1
    # print(newArr)  
    # 构建输出数组
    output_index = 0
    # enumerate()函数用于在遍历一个序列时获取每个元素的索引和值。
    # enumerate()会返回一个包含元素索引和元素值的元组。
    for i, count in enumerate(newArr):
        while count > 0:
            arr[output_index] = i + min_arr
            output_index += 1
            count -= 1
    return arr  
```


虽然计数排序看上去很强大，但是它存在两大局限性：

- 当数列最大最小值差距过大时，并不适用于计数排序

   比如给定 20 个随机整数，范围在 0 到 1 亿之间，此时如果使用计数排序的话，就需要创建长度为 1 亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。

- 当数列元素不是整数时，并不适用于计数排序

  如果数列中的元素都是小数，比如 3.1415，或是 0.00000001 这样子，则无法创建对应的统计数组，这样显然无法进行计数排序。正是由于这两大局限性，才使得计数排序不像快速排序、归并排序那样被人们广泛适用。

### 基数排序

## 树形结构

### BST二叉查找树

二叉查找树（BST）具备以下特性：

1. 左子树上所有结点的值均小于或等于它的根结点的值。
2. 右子树上所有结点的值均大于或等于它的根结点的值。
3. 左、右子树也分别为二叉排序树。

![1720360728213](D:\ruanjian\Typora\1720360728213.png)

但是二叉搜索树的缺点是，在插入数据的时候树的结构很有可能退化为链表，比如说如下：

![1720360511266](D:\ruanjian\Typora\1720360511266.png)

此时，搜索的时候，最坏情况的时间复杂度O(n) 。

### AVL平衡二叉树

也是属于二叉搜索树的一种，与其不同的是AVL通过机制保证其自身的平衡。

其他特性与二叉查找树一样，但是唯一不同的是他的**每个节点的左右子节点的高度之差的绝对值最多为1；**

#### AVL子树失衡的四大场景

##### LL型失衡-左左结构失衡（右旋）

 插入的元素在子树root的左侧不平衡元素的左侧

![1720361027226](D:\ruanjian\Typora\1720361027226.png)

##### RR型失衡：右右结构失衡（左旋）

插入的元素在子树root右侧的不平衡子树的右侧

![1720361172274](D:\ruanjian\Typora\1720361172274.png)

##### **LR型失衡：左右结构失衡（左旋+右旋）**

插入的元素在左侧的不平衡元素的右侧

![img](https://img-blog.csdnimg.cn/img_convert/a50f45a2c27e4f330603481789d5234c.png)

##### **RL失衡: 右左结构 （右旋+左旋）**

插入的元素在右侧的不平衡元素的左侧

![1720361315504](D:\ruanjian\Typora\1720361315504.png)









### 红黑树

红黑树是一个二叉搜索树，它在每个节点增加了一个存储位记录节点的颜色，可以是RED,也可以是BLACK；通过任意一条从根到叶子简单路径上颜色的约束，**红黑树保证最长路径不超过最短路径的二倍**，因而**近似平衡**。它同时满足以下特性：

- 节点非黑即红但是根节点一定是黑色

- 叶子节点（NIL）一定是黑色

- 每个红色节点的两个子节点，都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

- 从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。

![1720357805591](D:\ruanjian\Typora\1720357805591.png)

红黑树的查找，插入和删除操作，时间复杂度都是O(logN)。

红黑树的插入：

- 父为黑，直接插入
- 父叔为红，颜色调换
- 父红叔黑，颜色调换，在移动
- 父子不同向，先掰直再执行第三种情况

### 动态顺序统计

#### 顺序统计树

红黑树的升级版，与红黑树不同的是每个节点新增了一个信息用来计算每个节点的子树（包含他自己这个节点之内），如图所示：

![1720432957083](D:\ruanjian\Typora\1720432957083.png)

