# 1.javaScript

## 1.基础语法

```javascript
	prompt() //显示一个对话框,对话框中包含一条文字信息,用来提示用户输入文字
```

**let和var区别:**
	let为了解决var 的一些问题
		var 声明:
			可以先使用在声明(不合理)
			var声明过的变量可以重复声明(不合理)
			比如变量提升.全局变量.没有块级作用域等等

### 1.2.模板字符串

模板字符串:拼接字符串和变量,在没有它之前,要拼接变量比较麻烦
	语法:${}

```javascript
var name="张三";
document.write(`name:${name}`)
```

​	注意:包裹的必须是``
​	类型转换:
​		隐式转换
​			规则:+号两边只要有一个是字符串,都会把另外一个转成字符串，除了+以外的算术运算符 比如 - * / 等都会把数据转成数字类型
​	显示转换
​			隐式转换不严谨,而且隐式转换规律并不清晰,大多是靠经验总结的规律。
​			规则:
​			Number(数据)
​					转成数字类型
​					如果字符串里有非数字,转换失败时结果为 NaN(Not a Number)即不是一个数字,NaN也是number类型的数据,代表非数字
​			parseInt(数据)
​					只保留整数
​			parseFloat(数据)
​					可以保留小数
​			转换为字符型:
​					String(数据)
​					变量.toString(进制)
​			**注意:let变量不允许多次声明同一个变量**

### 1.3.操作数组

​	操作数组:
​		push():
​			数组.push()方法将一个或多个元素添加到数组的末尾,并返回该数组的新长度。
​		unshift():
​			arr.unshift(新增的内容) 方法将一个或多个元素添加到数组的开头,并返回该数组的新长度
​		pop()
​			数组.pop()方法从数组中删除最后一个元素,并返回该元素的值
​		shift()
​			数组.shift()方法从数组中删除第一个元素,并返回该元素的值
​		splice()
​			数组.splice()方法删除指定元素
​			splice(start,count); //start 删除的起始位置,count删除的个数

## 2.函数

​	用return返回数据
​		return会立即结束当前函数
​		函数可以没有return,这种情况函数默认返回值为undefined
​	作用域:全局作用域.局部作用域.块级作用域;
​		局部作用域:作用于函数内的代码环境;
​		块作用域由 {} 包括,if语句和for语句里面的{}等;
​		根据作用域不同,变量分为：全局变量、局部变量、块级变量
​	注意:局部变量或者块级变量没有let声明直接赋值的当全局变量看,这种很不提倡
​		在不同作用域下,可能存在变量命名冲突的情况,采取就近原则的方式来查找变量最终的值,作用域链；

```javascript		
	let num = 10
	function fn() {
		console.log(num)
	}
	fn();  //此处fn的值为20,遵循就近原则
```
匿名函数
​	将匿名函数赋值给一个变量,并且通过变量名称进行调用

```javascript
let fun=function(){
	alert('这就是匿名函数');
}
```

立即执行函数
​	场景介绍: 避免全局变量之间的污染

```javascript
(function () { console.log(111) })();
(function () { console.log(222) })();
```


​	**注意:多个立即执行函数要用;隔开,要不然会报错**

## 	3.对象

​	类比于java中的对象,写法类似与json格式
​	语法:

```javascript
	let 对象名={}
```

​	对象本质是无序的数据集合, 操作数据无非就是增、删、改、查语法:
​	删除对象中的属性:
​		delete 对象.属性
​	遍历对象
​		for k in obj
 		获得对象属性是 k
​		获得对象值是 obj[k]，例如：

```javascript
let obj = {
	uname: '小明',
	age: 18,
	sex: '男'
}
for (const key in obj) {
	console.log(key);//获取属性名
	console.log(obj[key]);//获取属性值
}
```
​	内置对象:即javascript内部提供的对象,包含各种属性和方法给开发者调用；
​	Math对象:

```javascript
生成N-M之间的随机数:Math.floor(Math.random() * (M - N + 1)) + N
```

## 4.web API
### 4.1.变量申明

​		变量声明有三个 var let 和 const
​			var老派写法,问题很多,可以淘汰掉
​			建议const优先,尽量使用const
​				const语义化更好,很多变量我们声明的时候就知道他不会被更改了
​			如果变量后期需要修改可以使用let
​		使用建议:
​			建议数组和对象使用const来声明
​			基本数据类型的值或者引用类型的地址发生变化的时候,需要用let

### 4.2.webAPI

​	Web API:就是使用js去操作浏览器和html,分为:DOM (文档对象模型).BOM(浏览器对象模型）
​	DOM树是什么
​		将HTML文档以树状结构直观的表现出来,我们称之为文档树或DOM 
​		作用:文档树直观的体现了标签与标签之间的关系
​	DOM的核心思想
​		把网页内容当做对象来处理
​	document对象
​		是DOM里提供的一个对象，它提供的属性和方法都是用来访问和操作网页内容的

网页所有内容都在document里面
根据CSS选择器来获取DOM元素
选择匹配的第一个元素:

```javascript
document.querySelector('css选择器');
```

​	参数:
​		   包含一个或多个有效的CSS选择器字符串
​	 返回值:
​			CSS选择器匹配的第一个元素,一个HTMLElement对象。如果没有匹配到,则返回null。
选择匹配的多个元素

```javascript
document.querySelectorAll('css选择器');
```

​	参数:
​			包含一个或多个有效的CSS选择器字符串
​	返回值:
​			CSS选择器匹配的NodeList对象集合

```javascript
querySelectAll()获取过来的也是一个伪数组,获取其中的元素需要遍历即可
// console.log(lis)
for (let i = 0; i < lis.length; i++) {
	console.log(lis[i]) // 每一个小li对象
}
```

#### 	操作元素内容

对象.innerText 属性

```javascript
//例:document.write()
const li = document.querySelector('li');
li.innerText = '<b>aaa</b>';//innerText不能解析标签,只是在对应的地方显示文本		
```

对象.innerHTML 属性

```javascript
const ps = document.querySelector('p');
ps.innerHTML=`<b>你好</b>`;		//innnerHTML可以解析标签
```

区别:
​		元素.innerText属性只识别文本,不能解析标签
​		元素.innerHTML属性能识别文本,能够解析标签
​		如果还在纠结到底用谁,你可以选择innerHTML

#### 	操作元素常用属性	

​		可以通过JS设置修改标签元素
​		语法:
​			对象.属性名=属性值;

#### 	操作元素样式属性

​		通过style属性操作CSS
​		语法:
​			对象.style.样式属性名=属性值;

```javascript
const divs = document.querySelector('div');
divs.style.backgroundColor = 'red'	
```

#### 	操作类名(className)

​		可以通过操作类名的方式操作属性
​		语法:
​			元素.className='类名'
​		使用类名的特点:可以同时修改多个样式,直接使用className赋值会覆盖以前的类名;

#### 	classList 操作类控制CSS	

​		这个主要是为了解决className赋值覆盖的问题
​		语法:
​			元素.classList.add('类名'); //追加一个类名
​			元素.classList.remove('类名');//删除一个类名
​			元素.classList.toggle('类名');//切换一个类名

```javascript
//实例	
const div= document.querySelector('.box');
div.classList.add('active');
div.classList.remove('active');
```

#### 	操作表单元素属性

​		表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示 
​		如果为true代表添加了该属性如果是false代表移除了该属性
​		比如:disabled.checked.selected

#### 	自定义属性

​		html5推出来了专门的data-自定义属性
​		在标签上一律以data-开头
​		获取的时候一律用dataset获取
```javascript
<div class="box" data-id="10">黑子</div>
const box=document.querySelector('.box');
console.log(box.dataset.id)
```

#### 	定时器-间歇函数

​		开启定时器
​			setInterVal(函数,间隔时间);
​		关闭定时器
​			cleatInterVal(timer);
​		示例:
```javascript
function fn() {
	console.log('一秒执行一次')
}
let n = setInterval(fn, 1000)
// setInterval('fn()', 1000)
console.log(n)
// 关闭定时器
clearInterval(n)
```
### 4.3.DOM事件操作

#### 	事件监听

元素对象.addEventListener('事件类型','要执行的函数');
​事件监听三要素:
​	事件源:那个dom元素被事件触发了,要获取dom元素
​	事件类型:用什么方式触发,比如鼠标单击click.鼠标经过mouseover等
​	事件调用的函数:要做什么

```javascript
const btn = document.querySelector('.btn');
btn.addEventListener('click',function(){
	alert('点击了');
})
```

​	常见的事件类型:
​		鼠标事件:click（鼠标点击）、mouseenter（鼠标经过）、mouseleave（鼠标离开））
​		焦点事件:focus（获得焦点）、blur（失去焦点）
​		键盘事件:keydown（键盘按下触发）、keyup（键盘抬起触发）
​		文本事件:input（用户输入事件）

#### 	事件对象

事件对象也是个对象,这个对象里有事件触发时的相关信息;
例如:鼠标点击事件中,事件对象就存了鼠标点在哪个位置等信息
​语法:

```js
元素.addEventListener('事件类型',function(e){
	console.log(e);//此处的e就是事件对象
})
```

常用属性
​	type
​			获取当前的事件类型
​	clientX/clientY
​			获取光标相对于浏览器可见窗口左上角的位置
​	offsetX/offsetY
​		获取光标相对于当前DOM元素左上角的位置
​	key
​			用户按下的键盘键

#### 	环境对象

​			环境对象:指的是函数内部特殊的变量this,它代表着当前函数运行时所处的环境
​			判断原则:谁调用,this就是谁。

#### 	回调函数	

​			如果将函数A做为参数传递给函数B时,我们称函数A为回调函数
​			简单理解:当一个函数当做参数来传递给另外一个函数
​		事件流
​			事件流指的是事件完整执行过程中的流动路径；
​			主要分为：事件捕获和事件冒泡
​				事件冒泡：当一个元素触发事件后，会依次向上调用所有父级元素的同名事件
​				例如：div -> 父级 -> document对象
​				事件捕获与之相反，且在实际开发中不常见
​			语法：
​				元素.addEventListener('事件类型','事件处理函数',是否使用捕获机制)
​				第三个参数默认为false(即事件冒泡),想要设置为事件捕获则将其设置为true;
​			阻止冒泡
​				目标：能够写出阻止冒泡的代码
​				问题：因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素
​				语法：
​					e.stopPropagation()

#### 	事件解绑

传统做法
​		直接给事件赋值为空即可

```javascript
const btn=document.querySelector('button');
btn.onclick=function(){
	alert('点击率');
	btn.onclick=null;
}
```

解绑事件	
​	removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段])

```javascript
const btn=document.querySelector('button');
function fn() {
		alert('点击了')
}
btn.addEventListener('click', fn)
// L2 事件移除解绑
btn.removeEventListener('click', fn)
```

注意:匿名函数无法被解绑,所以必须给解绑事件的第二个参数赋值一个函数名

#### 	 事件委托

​	事件委托是利用事件流的特征解决一些开发需求的知识技巧
​			优点：减少注册次数，可以提高程序性能
​			原理：事件委托其实是利用事件冒泡的特点。
​	给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件
​			实现：事件对象.target.tagName 可以获得真正触发事件的元素

```javascript
const ul = document.querySelector('ul');
ul.addEventListener('click', function (e) {
	if (e.target.tagName === 'LI') {
		e.target.style.color = 'red';
	}
})
```

#### 	其他事件

##### 	页面加载事件

加载外部资源（如图片.外联CSS和JavaScript等）加载完毕时触发的事件，有些时候需要等页面资源全部处理完了做一些事情
​老代码喜欢把 script 写在 head 中，这时候直接找监听页面所有资源加载完毕：
​给window 添加 load 事件：

```javascript
windows.addEventListener('load',function(){
	//执行操作
})
```

给dom添加load事件

```javascript
div.addEventListener('load',function(){
	//执行操作
})
```

当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表.图像等完全加载

```javascript
document.addEventListener('DOMContentLoaded', function () {
	//执行操作
})
```

##### 	元素滚动事件

滚动条在滚动的时候持续触发的事件
​监听整个页面滚动：
​给window或document添加scroll事件

```javascript
window.addEventListener('scroll', function () {
	//执行操作
})
```

监听某个元素的内部滚动直接给某个元素加即可：
​scrollLeft和scrollTop（属性）
​	获取被卷去的大小
​		获取元素内容往左.往上滚出去看不到的距离
​		这两个值是可读
​document.documentElement.scrollTop
​页面滚动事件-滚动到指定的坐标
​		scrollTo()方法可把内容滚动到指定的坐标
​		语法：	

```javascript
//将页面滚动到离x和y轴相应的位置
window.scrollTo(x,y);
```

##### 	页面尺寸事件

会在窗口尺寸改变的时候触发事件：

```javascript
window.addEventListener('resize', function () {
	//获取页面的宽度
	const w=document.documentElement.clientWidth;
})
```

获取宽高：
​		获取元素的可见部分宽高（不包含边框，margin，滚动条等）
​		clientWidth和clientHeight

##### 	元素尺寸于位置-尺寸

​		offsetWidth和offsetHeight
​		获取出来的是数值,方便计算
​		注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0
​		offsetLeft和offsetTop注意是只读属性

#### 日期对象
 const date=new Date();
​对应的方法可以参考api
​时间戳：用于获取1970年至今的毫秒数
​			date.getTime()
​			new Date()
​			Date.now()

### 4.4.DOM节点

DOM节点：DOM树里每一个内容都称之为节点
	元素节点 比如 div标签
	属性节点 比如 class属性
	文本节点 比如标签里
对节点进行增删改查
查找节点

```javascript
//查找父节点
子节点.parentNode  
//查找子节点
父节点.children 
//注意：此处获得的子节点是一个伪数组
//下一个兄弟节点
nextElementSibling 属性
//上一个兄弟节点
previousElementSibling 属性
```

删除节点

```javascript
父节点.removeChild(要删除的元素)
```

增加节点

```javascript
//创建节点
document.createElment('元素节点');
//增加节点，要想在界面看到，还得插入到某个父元素
父元素.insertBefore('要插入的元素','在哪个元素前面')
父元素.appendChild('要插入的元素')
```

 特殊情况下，我们新增节点，按照如下操作：  

​		1.复制一个原有的节点 

​		 2.把复制的节点放入到指定的元素内部

cloneNode会克隆出一个跟原标签一样的元素，括号内传入布尔值 

​	若为true，则代表克隆时会包含后代节点一起克隆 

​	若为false，则代表克隆时不包含后代节点 

​	默认为false

```javascript
const ul=document.querySelector('ul');
const li1=ul.children[0].cloneNode(true);
ul.appendChild(li1);//追加元素在ul中
```

### 4.5.BOM对象

#### 4.5.1.window对象

1. ##### BOM(浏览器对象模型) 

   BOM(Browser Object Model ) 是浏览器对象模型，像document.alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的。

2. ##### 定时器-延时函数 

   JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout，setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window，每一次调用延时器都会产生一个新的延时器

   ```javascript
   let timer=setTimeout(function () {
         img.style.display = 'none' //3秒之后，让图片消失
    }, 3000)
   //清除延时函数：
   clearTimeout(timer);
   ```

3. ##### JS执行机制

   1. 先执行执行栈中的同步任务。

   2. 异步任务放入任务队列中。 

   3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待 状态，进入执行栈，开始执行。

      JS 的异步是通过回调函数实现的。 一般而言，异步任务有以下三种类型: 

      ​	1.普通事件，如 click.resize 等 

      ​	2.资源加载，如 load.error 等 

      ​	3.定时器，包括 setInterval.setTimeout 等 异步任务相关添加到任务队列中（任务队列也称为消息队列)。

    由于主线程不断的重复获得任务.执行任务.再获取任务.再执行，所以这种机制被称为事件循环（ event loop) 。

4. ##### location对象 

   location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分 

   常用属性和方法： 

   ​	href 属性获取完整的 URL 地址，对其赋值时用于地址的跳转 

   ​	search 属性获取地址中携带的参数，符号 ？后面部分

   ​    hash 属性获取地址中的啥希值，符号 # 后面部分 

   ​    reload 方法用来刷新当前页面，传入参数 true 时表示强制刷新

5. ##### navigator对象

   navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息

6. ##### histroy对象

​		history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进.后退.历史记 录等

#### 4.5.2.本地存储

##### 1.本地存储简单数据类型

localStorage 把数据存储的浏览器中 ，可以将数据永久存储在本地(用户的电脑), 除非手动删除，否则关闭页面也会存在。

语法：

```javascript
//存储数据：
localStorage.setItem(key, value)
//获取数据
localStorage.getItem(key)
//删除数据
localStorage.removeItem(key)
```

**注意：存储的时候，如果原来有这个键，则是改，如果么有这个键是增**

```javascript
 localStorage.setItem('uname', 'red老师') //如果没有uname这个key，你们就是新增操作，否则就是修改uname的值的操作
 localStorage.removeItem('name');//删除操作
 localStorage.getItem('name');//获取元素操作
```

##### 2.本地存储复杂数据类型

本地只能存储字符串,无法存储复杂数据类型，如果需要存储复杂数据类型则需要类型转换，将复杂数据类型转换为json字符串存储在本地中。

```javascript
const obj = {
      uname: '张老师',
      age: 18,
      gender: '女'
    }
//本地只能存储字符串,无法存储复杂数据类型，需要解析成json格式
    localStorage.setItem('obj', JSON.stringify(obj));
    alert(localStorage.getItem('obj'))
```

浏览器要使用数据的时候，因为，本地存储里面取出来的是字符串，不是对象，无法直接使用。所以，需要将json字符串再转换为字符串。

```javascript
const str = JSON.parse(localStorage.getItem('obj'));
```

#### 4.5.3.数组中的相关方法

##### 1.map方法迭代数组

map 可以处理数据，并且返回新的数组

```javascript
const arr = ['张三', '李四', '王五'];
const newArr = arr.map(function (item, index) {
      console.log(item)
      console.log(index)
      return item + '老师';
 })
```

##### 2.数组中join方法

join() 方法用于把数组中的所有元素转换一个字符串，数组元素是通过参数里面指定的分隔符进行分隔的；

```javascript
const arr = ['张三', '李四', '王五'];
arr.join('*');
console.log( arr.join(';')) //张三;李四;王五
```

### 4.6.正则

#### 1.基本使用

1. 定义规则

   ~~~JavaScript
   const reg =  /表达式/
   ~~~

   其中` /   / `是正则表达式字面量，正则表达式也是对象 

2. 使用正则

   test()方法用来查看正则表达式与指定的字符串是否匹配，如果正则表达式与指定的字符串匹配 ，返回true，否则false

~~~html
 <script>
    // 正则表达式的基本使用
    const str = 'web前端开发'
    // 1. 定义规则
    const reg = /web/
    // 2. 使用正则test()
    console.log(reg.test(str))  // true  如果符合规则匹配上则返回true
    console.log(reg.test('java开发'))  // false  如果不符合规则匹配上则返回false
  </script>
~~~

#### 2.元字符

元字符是一些具有特殊含义的字符，可以极大提高了灵活性和强大的匹配功能。

比如，规定用户只能输入英文26个英文字母，换成元字符写法： /[a-z]/  

```javascript
  <script>
	const reg=/[a-z]/;
 	const str='sdsvfd';
 	console.log(reg.test(str));//true
  </script>
```

#### 3.边界符

  正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符^和$,其中^表示匹配开头，而$表示匹配结尾；

~~~html
<body>
  <script>
    // 元字符之边界符
    // 1. 匹配开头的位置 ^
    const reg = /^web/
    console.log(reg.test('web前端'))  // true
    console.log(reg.test('前端web'))  // false
    // 2. 匹配结束的位置 $
    const reg1 = /web$/
    console.log(reg1.test('web前端'))  //  false
    console.log(reg1.test('前端web'))  // true
    // 3. 精确匹配 ^ $
    const reg2 = /^web$/
    console.log(reg2.test('web前端'))  //  false 
  </script>
</body>
~~~

#### 4.量词

量词用来设定某个模式重复次数

**\+ 表示重复至少 1 次**

 **? 表示重复 0 次或1次** 

**表示重复 0 次或多次**

**{m, n} 表示复 m 到 n 次**

~~~html
<body>
  <script>
    // 元字符之量词
    // 1. * 重复次数 >= 0 次
    const reg1 = /^w*$/
    console.log(reg1.test(''))  // true
    console.log(reg1.test('w'))  // true
    console.log(reg1.test('ww'))  // true
    // 2. + 重复次数 >= 1 次
    const reg2 = /^w+$/
    console.log(reg2.test(''))  // false
    console.log(reg2.test('w'))  // true
    console.log(reg2.test('ww'))  // true
    // 3. ? 重复次数  0 || 1 
    const reg3 = /^w?$/
    console.log(reg3.test(''))  // true
    console.log(reg3.test('w'))  // true
    console.log(reg3.test('ww'))  // false
    // 4. {n} 重复 n 次
    const reg4 = /^w{3}$/
    console.log(reg4.test(''))  // false
    console.log(reg4.test('w'))  // flase
    console.log(reg4.test('ww'))  // false
    console.log(reg4.test('www'))  // true
    console.log(reg4.test('wwww'))  // false
  // 5. {n,} 重复次数 >= n 
    const reg5 = /^w{2,}$/
    console.log(reg5.test(''))  // false
    console.log(reg5.test('w'))  // false
    console.log(reg5.test('ww'))  // true
    console.log(reg5.test('www'))  // true
  // 6. {n,m}   n =< 重复次数 <= m
    const reg6 = /^w{2,4}$/
    console.log(reg6.test('w'))  // false
    console.log(reg6.test('ww'))  // true
    console.log(reg6.test('www'))  // true
    console.log(reg6.test('wwww'))  // true
    console.log(reg6.test('wwwww'))  // false
  </script>
~~~

**注意：{n,m}   n =< 重复次数 <= m中，逗号两侧千万不要加空格否则会匹配失败**

#### 5.范围

表示字符的范围，定义的规则限定在某个范围，比如只能是英文字母，或者数字等等，用表示范围

~~~html
 <script>
    // 元字符之范围  []  
    // 1. [abc] 匹配包含的单个字符， 多选1
    const reg1 = /^[abc]$/
    console.log(reg1.test('a'))  // true
    console.log(reg1.test('d'))  // false
    console.log(reg1.test('ab'))  // false
    // 2. [a-z] 连字符 单个
    const reg2 = /^[a-z]$/
    console.log(reg2.test('a'))  // true
    console.log(reg2.test('A'))  // false
    // 想要包含小写字母，大写字母 ，数字
    const reg3 = /^[a-zA-Z0-9]$/
    console.log(reg3.test('B'))  // true
    console.log(reg3.test('b'))  // true
    console.log(reg3.test(9))  // true
    console.log(reg3.test(','))  // flase
    // 用户名可以输入英文字母，数字，可以加下划线，要求 6~16位
    const reg4 = /^[a-zA-Z0-9_]{6,16}$/
    console.log(reg4.test('abcd1'))  // false 
    console.log(reg4.test('abcd12'))  // true
    console.log(reg4.test('ABcd12'))  // true
    console.log(reg4.test('ABcd12_'))  // true
    // 3. [^a-z] 取反符
    const reg5 = /^[^a-z]$/
    console.log(reg5.test('a'))  // false 
    console.log(reg5.test('A'))  // true
    console.log(reg5.test(8))  // true
  </script>
</body>
~~~

#### 6.字符类

某些常见模式的简写方式，区分字母和数字

```javascript
\d 匹配0-9的任意数字，相当于[0-9]
\D 匹配0-9以外数字，相当于[^0-9]
\w 匹配任意的数字和字符和下划线，相当于[a-zA-Z0-9_]
\W 与上面的\w相反 [^a-zA-Z0-9_]
\s 匹配所有的空格.换行符.制表符
\S 与上面相反
```

#### 7.替换和修饰符

replace 替换方法，可以完成字符的替换

~~~html
 <script>
    // 替换和修饰符
    const str = '欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神'
    // 1. 替换  replace  需求：把前端替换为 web
    // 1.1 replace 返回值是替换完毕的字符串
  const strEnd = str.replace(/前端/, 'web') 只能替换一个
  </script>
~~~

修饰符约束正则执行的某些细节行为，如是否区分大小写.是否支持多行匹配等

- i 是单词 ignore 的缩写，正则匹配时字母不区分大小写
- g 是单词 global 的缩写，匹配所有满足正则表达式的结果

~~~javascript
  <script>
    // 替换和修饰符
    const str = '欢迎大家学习前端，相信大家一定能学好前端，都成为前端大神'
    // 1. 替换replace需求：把前端替换为 web
    // 1.1 replace 返回值是替换完毕的字符串
    const strEnd = str.replace(/前端/, 'web') //只能替换一个
    // 2. 修饰符 g 全部替换
    const strEnd = str.replace(/前端/g, 'web')
    console.log(strEnd) 
  </script>
~~~

## 5.javascript进阶

### 5.1.作用域链

作用域链本质上是底层的变量查找机制。 

Ø 在函数被执行时，会优先查找当前函数作用域中查找变量 

Ø 如果当前作用域查找不到则会依次逐级查找父级作用域直到全局作用域

注意：

1. 嵌套关系的作用域串联起来形成了作用域链 
2. 相同作用域链中按着从小到大的规则查找变量
3. 子作用域能够访问父作用域，父级作用域无法访问子级作用域

### 5.2.JS垃圾回收机制

垃圾回收机制(Garbage Collection) 简称 GC，JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收。

JS环境中分配的内存, 一般有如下生命周期： 

内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存 

内存使用：即读写内存，也就是使用变量、函数等 

内存回收：使用完毕，由垃圾回收自动回收不再使用的内存 

说明 

全局变量一般不会回收(关闭页面回收)； 

一般情况下局部变量的值, 不用了, 会被自动回收掉；

### 5.3.闭包 

概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域 

简单理解：闭包 =  内层函数 + 外层函数的变量

```javascript
//闭包的使用  
function count(){
    //此处如果i为全局变量，那么变量的值就很容易被修改，
    //但是如果是使用闭包，那么就可以保证数据不容易被轻易修改
  let i=0;
  function fun(){
   i++;
   console.log(`函数被调用了${i}次数`)
  }
  return fun
}
const sum= count();
```

注意：

闭包的作用 

Ø 封闭数据，实现数据私有，外部也可以访问函数内部的变量 

Ø 闭包很有用，因为它允许将函数与其所操作的某些数据(环境)关联起来 

闭包可能引起的问题 

内存泄漏

### 5.3.变量提升

变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问（仅存在于var声明变量）

```javascript
console.log(str+'hello');
var str='javascript';
```

### 5.4.函数提升

函数提升与变量提升比较类似，是指函数在声明之前即可被调用

总结： 

1. 函数提升能够使函数的声明调用更灵活 
2. 函数表达式不存在提升的现象 
3. 函数提升出现在相同作用域当中

```javascript
foo();
function foo(){
    console.log('申明之前调用');
}
foo2();
const foo2=function(){
    console.log(' 函数表达式不存在提升的现象');//错误的写法，不能够这样表示
}
```

### 5.5.函数参数

#### 动态参数 

arguments 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参

```javascript
//解决传入不定个数个参数时的函数
function sum(){
    let s=0;
    for(let i=0;i<arguments.length;i++){
      s+=arguments[i]
    }
    console.log(s)
  }
  sum(12,434)//446
  sum(12,3,23,4,55)//97
```

1. arguments 是一个伪数组，只存在于函数中 
2. arguments 的作用是动态获取函数的实参 
3. 可以通过for循环依次得到传递过来的实参

#### 剩余参数

用于获取多余的实参

```javascript
function getSum(...other){
	console.log(other);//12,23,45,33
}
getSum(12,23,45,33);
```

总结：

1. `...` 是语法符号，置于最末函数形参之前，用于获取多余的实参
2. 借助 `...` 获取的剩余实参，是个真数组

#### 展开运算符

展开运算符(…),将一个数组进行展开，不会修改原数组；

典型运用场景： 求数组最大值(最小值)、合并数组等

```javascript
const arr=[12,3,4,5,6];
console.log(...arr);//12,3,4,5,6
console.log(Math.max(...arr));//12
const arr1=[6,7,8,9];
const arr3=[...arr,...arr1];//12,3,4,5,6,6,7,8,9
```

### 5.6.箭头函数

箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。

```javascript
const fn=()=>{
    console.log('1234')
}
fn()
const onlyOne=x=>{       //只有一个形参的时候，可以省略小括号
    console.log(x)
}
onlyOne(3)
// 3. 只有一行代码的时候，我们可以省略大括号
const fns = x => console.log(x)
fns(1)
// 4. 只有一行代码的时候，可以省略return
const fnn = x => x + x
console.log(fnn(1))
// 5. 箭头函数可以直接返回一个对象
const fn = (uname) => ({ uname: uname })
console.log(fn('刘德华'))
```

总结：

1. 箭头函数属于表达式函数，因此不存在函数提升
2. 箭头函数只有一个参数时可以省略圆括号 `()`
3. 箭头函数函数体只有一行代码时可以省略花括号 `{}`，并自动做为返回值被返回

#### 参数

箭头函数中没有 `arguments`，只能使用 `...` 动态获取实参

~~~js
 <script>
    // 1. 利用箭头函数来求和
    const getSum = (...arr) => {
      let sum = 0
      for (let i = 0; i < arr.length; i++) {
        sum += arr[i]
      }
      return sum
    }
    const result = getSum(2, 3, 4)
    console.log(result) // 9
  </script>
~~~

#### 箭头函数 this

箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。

```js
//箭头函数的this是上一层作用域的this 指向
const fn = () => {
   console.log(this)  // window
}
fn()
// 对象方法箭头函数 this
const obj = {
   uname: 'pink老师',
   sayHi: () => {
   		console.log(this)  // this 指向谁？ window
   }
}
obj.sayHi()
```

### 5.7.解构赋值

解构赋值是一种快速为变量赋值的简洁语法，本质上仍然是为变量赋值，分为数组解构、对象解构两大类型。

#### 数组解构

数组解构是将数组的单元值快速批量赋值给一系列变量的简洁语法，如下代码所示：

```js
let arr=[1,2,4];
// 批量声明变量 a b c 
// 同时将数组单元值 1 2 3 依次赋值给变量 a b c
let [a,b,c]=arr;
console.log(a)//1
console.log(b)//2
console.log(c)//4
```

总结：

1. 赋值运算符 `=` 左侧的 `[]` 用于批量声明变量，右侧数组的单元值将被赋值给左侧的变量
2. 变量的顺序对应数组单元值的位置依次进行赋值操作
3. 变量的数量大于单元值数量时，多余的变量将被赋值为  `undefined`
4. 变量的数量小于单元值数量时，可以通过 `...` 获取剩余单元值，但只能置于最末位
5. 允许初始化变量的默认值，且只有单元值为 `undefined` 时默认值才会生效

注：支持多维解构赋值，比较复杂后续有应用需求时再进一步分析

#### 对象解构

对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法，如下代码所示：

```html
<script>
  // 普通对象
  const user = {
    name: '小明',
    age: 18
  };
  // 批量声明变量 name age
  // 同时将数组单元值 小明  18 依次赋值给变量 name  age
  const {name, age} = user
  console.log(name) // 小明
  console.log(age) // 18
</script>
```

总结：

1. 赋值运算符 `=` 左侧的 `{}` 用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2. 对象属性的值将被赋值给与属性名相同的变量
3. 对象中找不到与变量名一致的属性时变量值为 `undefined`
4. 允许初始化变量的默认值，属性不存在或单元值为 `undefined` 时默认值才会生效

注：支持多维解构赋值

## 6.深入对象

### 6.1.构造函数

构造函数是专门用于创建对象的函数，如果一个函数使用 `new` 关键字调用，那么这个函数就是构造函数。

```html
<script>
  // 定义函数
  function foo() {
    console.log('通过 new 也能调用函数...');
  }
  // 调用函数
  new foo;
</script>
```

总结：

2. 使用 `new` 关键字调用函数的行为被称为实例化
3. 实例化构造函数时没有参数时可以省略 `()`
4. 构造函数的返回值即为新创建的对象
5. 构造函数内部的 `return` 返回的值无效！

注：实践中为了从视觉上区分构造函数和普通函数，习惯将构造函数的首字母大写。

### 6.2.实例成员

通过构造函数创建的对象称为实例对象，实例对象中的属性和方法称为实例成员。

```html
<script>
  // 构造函数
  function Person() {
    // 构造函数内部的 this 就是实例对象
    // 实例对象中动态添加属性
    this.name = '小明'
    // 实例对象动态添加方法
    this.sayHi = function () {
      console.log('大家好~')
    }
  }
  // 实例化，p1 是实例对象
  // p1 实际就是 构造函数内部的 this
  const p1 = new Person()
  console.log(p1)
  console.log(p1.name) // 访问实例属性
  p1.sayHi() // 调用实例方法
</script>
```

总结：

1. 构造函数内部 `this` 实际上就是实例对象，为其动态添加的属性和方法即为实例成员
2. 为构造函数传入参数，动态创建结构相同但值不同的对象

注：构造函数创建的实例对象彼此独立互不影响。

### 6.3.静态成员

在 JavaScript 中底层函数本质上也是对象类型，因此允许直接为函数动态添加属性或方法，构造函数的属性和方法被称为静态成员。

```html
<script>
  // 构造函数
  function Person(name, age) {
    // 省略实例成员
  }
  // 静态属性
  Person.eyes = 2
  Person.arms = 2
  // 静态方法
  Person.walk = function () {
    console.log('^_^人都会走路...')
    // this 指向 Person
    console.log(this.eyes)
  }
</script>
```

总结：

1. 静态成员指的是添加到构造函数本身的属性和方法
2. 一般公共特征的属性或方法静态成员设置为静态成员
3. 静态成员方法中的 `this` 指向构造函数本身

### 6.4.内置构造函数

在 JavaScript 中**最主要**的数据类型有 6 种，分别是字符串、数值、布尔、undefined、null 和 对象，常见的对象类型数据包括数组和普通对象。其中字符串、数值、布尔、undefined、null 也被称为简单类型或基础类型，对象也被称为引用类型。

在 JavaScript 内置了一些构造函数，绝大部的数据处理都是基于这些构造函数实现的， `Date` 函数就是内置的构造函数。

```html
<script>
  // 实例化
	let date = new Date();
  // date 即为实例对象
  console.log(date);
</script>
```

甚至字符串、数值、布尔、数组、普通对象也都有专门的构造函数，用于创建对应类型的数据。

#### Object

`Object` 是内置的构造函数，用于创建普通对象。

```html
<script>
  // 通过构造函数创建普通对象
  const user = new Object({name: '小明', age: 15})
  // 这种方式声明的变量称为【字面量】
  let student = {name: '杜子腾', age: 21}
  // 对象语法简写
  let name = '小红';
  let people = {
    // 相当于 name: name
    name,
    // 相当于 walk: function () {}
    walk () {
      console.log('人都要走路...');
    }
  }
  console.log(student.constructor);
  console.log(user.constructor);
  console.log(student instanceof Object);
</script>
```

总结：

1. 推荐使用字面量方式声明对象，而不是 `Object` 构造函数
2. `Object.assign` 静态方法创建新的对象
3. `Object.keys` 静态方法获取对象中所有属性
4. `Object.values` 表态方法获取对象中所有属性值

#### Array

`Array` 是内置的构造函数，用于创建数组。

```html
<script>
  // 构造函数创建数组
  let arr = new Array(5, 7, 8);
  // 字面量方式创建数组
  let list = ['html', 'css', 'javascript']
</script>
```

数组赋值后，无论修改哪个变量另一个对象的数据值也会相当发生改变。

总结：

1. 推荐使用字面量方式声明数组，而不是 `Array` 构造函数

2. 实例方法 `forEach` 用于遍历数组，替代 `for` 循环 (重点)

3. 实例方法 `filter` 过滤数组单元值，生成新数组(重点)

4. 实例方法 `map` 迭代原数组，生成新数组(重点)

5. 实例方法 `join` 数组元素拼接为字符串，返回字符串(重点)

6. 实例方法  `find`  查找元素， 返回符合测试条件的第一个数组元素值，如果没有符合条件的则返回 undefined(重点)

7. 实例方法`every` 检测数组所有元素是否都符合指定条件，如果**所有元素**都通过检测返回 true，否则返回 false(重点)

8. 实例方法`some` 检测数组中的元素是否满足指定条件   **如果数组中有**元素满足条件返回 true，否则返回 false

9. 实例方法 `concat`  合并两个数组，返回生成新数组

10. 实例方法 `sort` 对原数组单元值排序

11. 实例方法 `splice` 删除或替换原数组单元

12. 实例方法 `reverse` 反转数组

13. 实例方法 `findIndex`  查找元素的索引值


#### 包装类型

在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，如下代码举例：

```html
<script>
  // 字符串类型
  const str = 'hello world!'
 	// 统计字符的长度（字符数量）
  console.log(str.length)
  // 数值类型
  const price = 12.345
  // 保留两位小数
  price.toFixed(2) // 12.34
</script>
```

之所以具有对象特征的原因是字符串、数值、布尔类型数据是 JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型。

#### String

`String` 是内置的构造函数，用于创建字符串。

```html
<script>
  // 使用构造函数创建字符串
  let str = new String('hello world!');

  // 字面量创建字符串
  let str2 = '你好，世界！';

  // 检测是否属于同一个构造函数
  console.log(str.constructor === str2.constructor); // true
  console.log(str instanceof String); // false
</script>
```

总结：

1. 实例属性 `length` 用来获取字符串的度长(重点)
2. 实例方法 `split('分隔符')` 用来将字符串拆分成数组(重点)
3. 实例方法 `substring（需要截取的第一个字符的索引[,结束的索引号]）` 用于字符串截取(重点)
4. 实例方法 `startsWith(检测字符串[, 检测位置索引号])` 检测是否以某字符开头(重点)
5. 实例方法 `includes(搜索的字符串[, 检测位置索引号])` 判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false
5. 实例方法 `toUpperCase` 用于将字母转换成大写
7. 实例方法 `toLowerCase` 用于将就转换成小写
8. 实例方法 `indexOf`  检测是否包含某字符
9. 实例方法 `endsWith` 检测是否以某字符结尾
10. 实例方法 `replace` 用于替换字符串，支持正则匹配
13. 实例方法 `match` 用于查找字符串，支持正则匹配

注：String 也可以当做普通函数使用，这时它的作用是强制转换成字符串数据类型。

#### Number

`Number` 是内置的构造函数，用于创建数值。

```html
<script>
  // 使用构造函数创建数值
  let x = new Number('10')
  let y = new Number(5)
  // 字面量创建数值
  let z = 20
</script>
```

总结：

1. 推荐使用字面量方式声明数值，而不是 `Number` 构造函数
2. 实例方法 `toFixed` 用于设置保留小数位的长度

### 6.5.封装

封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之间是彼此不影响的。

```html
<script>
  function Person() {
    this.name = '佚名'
    // 设置名字
    this.setName = function (name) {
      this.name = name
    }
    // 读取名字
    this.getName =() => {
      console.log(this.name)
    }
  }
  // 实例对像，获得了构造函数中封装的所有逻辑
  let p1 = new Person()
  p1.setName('小明')
  console.log(p1.name);//小明
  // 实例对象
  let p2 = new Person()
  console.log(p2.name)//佚名
</script>
```

总结：

​		构造函数体现了面向对象的封装特性

​		构造函数实例创建的对象彼此独立、互不影响

# 2.Ajax

### 1.初识Ajax

URL地址一般由三部组成： 

​		① 客户端与服务器之间的通信协议

​		② 存有该资源的服务器名称 

​		③ 资源在服务器上具体的存放位置

```js
https://mbd.baidu.com/newspage/data/index.html
https:  通信协议
mbd.baidu.com  服务器名称
newspage/data/index.html   资源在服务器上具体的存放位置
```

 get 请求通常用于获取服务端资源（向服务器要资源） 

​		例如：根据 URL 地址，从服务器获取 HTML 文件、css 文件、js文件、图片文件、数据资源等 

post 请求通常用于向服务器提交数据（往服务器发送资源） 

​		例如：登录时向服务器提交的登录信息、注册时向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作

Ajax的理解:在网页中利用 XMLHttpRequest 对象和服务器进行数据交互的方式，就是Ajax。

### 2.jQuery中的Ajax

浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一 系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。 

jQuery 中发起 Ajax 请求最常用的三个方法如下： 

- $.get() 
- $.post()
- $.ajax()

#### $.get()函数

jQuery 中 $.get() 函数的功能单一，专门用来发起 get 请求，从而将服务器上的资源请求到客户端来进行使用。

```js
$.get(url, [data], [callback])
//url string 是必选示要请求的资源地址
//data object 不是必选表示请求资源期间要携带的参数
//callback function 不是必选表示请求成功时的回调函数
```

使用 $.get() 函数发起不带参数的请求时，直接提供请求的 URL 地址和请求成功之后的回调函数即可，示例代 码如下：

```js
$.get('http://www.liulongbin.top:3006/api/getbooks', function(res) { 
    console.log(res) // 这里的 res 是服务器返回的数据 
})
```

使用 $.get() 函数发起带参数的请求时，示例代码如下：

```js
$.get('http://www.liulongbin.top:3006/api/getbooks', {id: 1}, function(res) { 
    console.log(res) 
})
```

#### $.post()函数

jQuery 中 $.post() 函数的功能单一，专门用来发起 post请求，从而将服务器上的资源请求到客户端来进行使用。

```js
$.post(url, [data], [callback])
//url string 是必选示要提交数据的地址
//data object 不是必选表示要提交的数据
//callback function 不是必选表示数据提交成功时的回调函数
```

使用 $.post() 向服务器提交数据的示例代码如下：

```js
$.post('http://www.liulongbin.top:3006/api/addbook', // 请求的URL地址
	{ bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' }, // 提交的数据
	function(res) { // 回调函数
	console.log(res)
})
```

#### $.ajax()函数 

相比于 $.get() 和 $.post() 函数，jQuery 中提供的 $.ajax() 函数，是一个功能比较综合的函数，它允许我们对 Ajax 请求进行更详细的配置。 

$.ajax() 函数的基本语法如下：

```js
$.ajax({ type: '', // 请求的方式，例如 GET 或 POST 
        url: '', // 请求的 URL 地址 
        data: { },// 这次请求要携带的数据 
        success: function(res) { 
        	//内容
        } // 请求成功之后的回调函数 
})
```

使用 $.ajax() 发起 GET 请求时，只需要将 type 属性的值设置为 'GET' 即可： 

```js
$.ajax({ 
    type: 'GET', // 请求的方式 
    url: 'http://www.liulongbin.top:3006/api/getbooks', // 请求的 URL 地址 
    data: { id: 1 },// 这次请求要携带的数据 
    success: function(res) { 
        // 请求成功之后的回调函数 
        console.log(res) 
    } 
})
```

使用 $.ajax() 发起 POST 请求时，只需要将 type 属性的值设置为 'POST' 即可： 

```js
$.ajax({ type: 'POST', // 请求的方式 
        url: 'http://www.liulongbin.top:3006/api/addbook', // 请求的 URL 地址 
        data: { // 要提交给服务器的数据 
            bookname: '水浒传', author: '施耐庵', publisher: '上海图书出版社' 
        }, 
        success: function(res) { 
            // 请求成功之后的回调函数 console.log(res) 
        } 
})
```

### 3.axios使用

使用 axios 函数

- 传入配置对象

- 再用 .then 回调函数接收结果，并做后续处理

```js
//引入 axios.js：https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
axios() { 
    url: '目标资源地址' 
}.then((result)=>{
	// 对服务器返回的数据做后续处理
})
```

示例

```js
axios({
    url:"http://hmajax.itheima.net/api/province"
}).then(result=>{
    console.log(result)//获取到result对象
    console.log(result.data.list)//获取到result对象里面的数据
})
```

#### axios－查询参数 

语法：使用 axios 提供的 params 选项 

注意：axios 在运行时把参数名和值，会拼接到 url?参数名=值

```js
axios({ 
    url:'目标资源地址', 
    params:{参数名:值}}).then(result=>{ 
    // 对服务器返回的数据做后续处理 
})
```

示例

```js
axios({
    url:"http://hmajax.itheima.net/api/city",
    params:{
     pname:'甘肃省'
    }
	}).then(result=>{
    console.log(result.data.list)//['兰州市', '嘉峪关市', '金昌市', '白银市', '天水市', '武威市', '张掖市', '平凉市', 								// '酒泉市', '庆阳市', '定西市', '陇南市', '临夏回族自治州', '甘南藏族自治州']
})
```

#### 常用请求方法 

请求方法：对服务器资源，要执行的操作 

请求方法		   操作 

- GET 		    获取数据 
- POST          数据提交 
- PUT             修改数据（全部） 
- DELETE       删除数据 
- PATCH        修改数据（部分）

##### 数据提交

axios 请求配置

-  url：请求的 URL 网址 
- method：请求的方法，
- GET可以省略（不区分大小写） 
- data：提交数据

```js
axios({
    url: '目标资源地址',
    method: '请求方法',
	data: {
		参数名: 值
	}
}).then((result) => { // 对服务器返回的数据做后续处理 })
```

示例：


```js
<button class="btn">注册用户</button>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>
	document.querySelector('.btn').addEventListener('click', () => {
  	axios({
    	url: 'http://hmajax.itheima.net/api/register',
    	method: 'POST',
    	data: {
      		username: 'itheima007',
      		password: '7654321'
    	}
  	})
})
</script>
```
#### axios 错误处理

语法：在 then 方法的后面，通过点语法调用 catch 方法，传入回调函数并定义形参

```js
axios({ 
    // 请求选项 
}).then(result => {
    // 处理数据 
}).catch(error => { 
    // 处理错误 
})
```

示例

```js
axios({
    url: 'http://hmajax.itheima.net/api/register',
    method: 'post',
    data: {
     	username: '张佳亮123123',
     	password: '2234343'
    }
   }).then(result => {
    	console.log(result.data)
   }).catch(errror => {
    	console.log(error)
    	console.log(error.response.data.message)
    	alert(error.response.data.message)
   })
  })
```

#### form-serialize 插件

作用：快速收集表单元素的值

```js
/**
          * 2. 使用serialize函数，快速收集表单元素的值
          * 参数1：要获取哪个表单的数据
          *  表单元素设置name属性，值会作为对象的属性名
          *  建议name属性的值，最好和接口文档参数名一致
          * 参数2：配置对象
          *  hash 设置获取数据结构
          *    - true：JS对象（推荐）一般请求体里提交给服务器
          *    - false: 查询字符串
          *  empty 设置是否获取空值
          *    - true: 获取空值（推荐）数据结构和标签结构一致
          *    - false：不获取空值
*/   
const form = document.querySelector('.example-form')
const data = serialize(form, { hash: true, empty: true })
```

# 3.Git

## 1.常见的版本控制工具

主流的版本控制器有如下这些：

- **Git**
- **SVN**（Subversion）
- **CVS**（Concurrent Versions System）
- **VSS**（Micorosoft Visual SourceSafe）
- **TFS**（Team Foundation Server）
- Visual Studio Online

### 集中版本控制  SVN

所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS

### 分布式版本控制Git

每个人都拥有全部的代码！安全隐患！

所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。不会因为服务器损坏或者网络问题，造成不能工作的情况！

## Git

安装完成Git之后，会有一下三个图标：

**Git Bash：**Unix与Linux风格的命令行，使用最多，推荐最多

**Git CMD：**Windows风格的命令行

**Git GUI**：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令

相关命令

```cmd
#查看系统config
git config --system --list　　
#查看当前用户（global）配置
git config --global  --list
# 设置用户名与邮箱（用户标识，必要）
git config --global user.name "kuangshen"  #名称
git config --global user.email 24736743@qq.com   #邮箱
```

### 三个区域

- Workspace：工作区，就是你平时存放项目代码的地方
- Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息
- Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本
- Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换

### 工作流程

git的工作流程一般是这样的：

１、在工作目录中添加、修改文件；

２、将需要进行版本管理的文件放入暂存区域；

３、将暂存区域的文件提交到git仓库。

因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)

### 本地仓库搭建

创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。

1、创建全新的仓库，需要用GIT管理的项目的根目录执行：

2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。

```cmd
# 在当前目录新建一个Git代码库
$ git init
```

### 克隆远程仓库

1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！

```cmd
# 克隆一个项目和它的整个代码历史(版本信息)
$ git clone [url] 
```

### 文件的四种状态

版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。

- Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.
- Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件
- Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !
- Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified

```cmd
#查看指定文件状态
git status [filename]
#查看所有文件状态
git status
#添加所有文件到暂存区
git add .  
# 提交暂存区中的内容到本地仓库 -m 提交信息
git commit -m "消息内容"    
```

### 忽略文件

有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等

在主目录下建立".gitignore"文件，此文件有如下规则：

1. 忽略文件中的空行或以井号（#）开始的行将会被忽略。
2. 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。
3. 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。
4. 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。
5. 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。

```cmd
#为注释
*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！
!lib.txt     #但lib.txt除外
/temp        #仅忽略项目根目录下的TODO文件,不包括其它目录temp
build/       #忽略build/目录下的所有文件
doc/*.txt    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
```

绑定SSH公钥，实现免密码登录！

```cmd
# 进入 C:\Users\Administrator\.ssh 目录
# 生成公钥
ssh-keygen
```

### GIT分支

分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！

```cmd
# 列出所有本地分支
git branch
# 列出所有远程分支
git branch -r
# 新建一个分支，但依然停留在当前分支
git branch [branch-name]
# 新建一个分支，并切换到该分支
git checkout -b [branch]
# 合并指定分支到当前分支
$ git merge [branch]
# 删除分支
$ git branch -d [branch-name]
# 删除远程分支
$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]
```

如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！

master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。

# 4.node.js

## 1.node.js与内置模块

### 初始node.js

 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 的官网地址： https://nodejs.org/zh-cn

Node.js 作为一个 JavaScript 的运行环境，仅仅提供了基础的功能和 API。然而，基于 Node.js 提供的这些基础能，很多强大 的工具和框架如雨后春笋，层出不穷，所以学会了 Node.js ，可以让前端程序员胜任更多的工作和岗位：

 	  ① 基于 Express 框架（http://www.expressjs.com.cn/），可以快速构建 Web 应用 

​		② 基于 Electron 框架（https://electronjs.org/），可以构建跨平台的桌面应用

​		③ 基于 restify 框架（http://restify.com/），可以快速构建 API 接口项目

​		④ 读写和操作数据库、创建实用的命令行工具辅助前端开发、etc… 

### fs文件系统模块

#### 读写文件操作

​	fs 模块是 Node.js 官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。 

例如： 

- ​		fs.readFile() 方法，用来读取指定文件中的内容 

- ​		fs.writeFile() 方法，用来向指定的文件中写入内容


```javascript
//导入fs模块，用来读文件
const fs=require('fs')
//从1.txt文本中读取文件，文件格式为utf-8
fs.readFile('../1.txt','utf-8',function(err,dataStr){
    //打印失败的结果
    if(err){
        return console.log('读取文件失败'+err.message)
    }
    console.log('读取文件成功'+dataStr)
})
//写文件操作
fs.writeFile('../1.txt','你好，node',function(err){
    //如果写入成功则err成功，其值为null，如果失败err的值为一个对象
    // console.log(err);
    if(err){
        return console.log('文件写入失败'+err.message)
    }else{
        console.log('文件写入成功 ')
    }
})
```

#### fs 模块 - 路径动态拼接的问题

在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，很容易出现路径动态拼接错误的问题。 原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径。 解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，不要提供 ./ 或 ../ 开头的相对路径，从而防止路径动态拼接的问题。

### path路径模块

path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理 需求。 

例如： 

​		 **path.join() 方法，用来将多个路径片段拼接成一个完整的路径字符串** 

​		 **path.basename() 方法，用来从路径字符串中，将文件名解析出来**

```javascript
//引入path路径模块
const path=require('path');
//其中../会抵消前一个目录
//__dirname标识当前的路径
 const path1=pathFile.join(__dirname,'/a','/b/c','../','./d')
 console.log(path1);//输出的结果为/a/b/d
const fpath='/a/b/c/index.html'
const fullName=path.basename(fpath) 
//获取文件名称
console.log(fullName)//输出结果为index.html
console.log('--------------------')
//获取文件名称，不带扩展名
const nameWithoutEnd=path.basename(fpath,'.html')
console.log(nameWithoutEnd) //输出结果为index
```

**注意：今后凡是涉及到路径拼接的操作，都要使用 path.join() 方法进行处理。不要直接使用 + 进行字符串的拼接**

### http模块

#### 基本介绍

http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的 http.createServer() 方法，就 能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。

创建 web 服务器的基本步骤 

​	 ① 导入 http 模块 

​	 ② 创建 web 服务器实例

 	③ 为服务器实例绑定 request 事件，监听客户端的请求
 	
 	④ 启动服务器

```javascript
// 1. 导入 http 模块
const http = require('http')
// 2. 创建 web 服务器实例
const server = http.createServer()
// 3. 为服务器实例绑定 request 事件，监听客户端的请求
server.on('request', function (req, res) {
  console.log('Someone visit our web server.')
})
// 4. 启动服务器
server.listen(8080, function () {  
  console.log('server running at http://127.0.0.1:8080')
})
```

#### req 请求对象和res响应对象

req请求对象：只要服务器接收到了客户端的请求，就会调用通过 server.on() 为服务器绑定的 request 事件处理函数。

res响应对象：在服务器的 request 事件处理函数中，如果想访问与服务器相关的数据或属性，可以使用如下的方式：

```javascript
// req 是请求对象，包含了与客户端相关的数据和属性
server.on('request', (req, res) => {
  // req.url 是客户端请求的 URL 地址
  const url = req.url
  // req.method 是客户端请求的 method 类型
  const method = req.method
  const str = `Your request url is ${url}, and request method is ${method}`
  console.log(str)
  // 调用 res.end() 方法，向客户端响应一些内容
  res.end(str)
})
```

#### 解决乱码问题

当调用 res.end() 方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式：

```javascript
server.on('request', (req, res) => {
  // 定义一个字符串，包含中文的内容
  const str = `您请求的 URL 地址是 ${req.url}，请求的 method 类型为 ${req.method}`
  // 调用 res.setHeader() 方法，设置 Content-Type 响应头，解决中文乱码的问题
  res.setHeader('Content-Type', 'text/html; charset=utf-8')
  // res.end() 将内容响应给客户端
  res.end(str)
})
```

## 2.模块化

###  基本概念 

模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元

把代码进行模块化拆分的好处： 

​		① 提高了代码的复用性 

​		② 提高了代码的可维护性 

​		③ 可以实现按需加载

###  Node.js 中模块化 

#### 基本介绍

Node.js 中根据模块来源的不同，将模块分为了 3 大类，分别是：

​		内置模块（内置模块是由 Node.js 官方提供的，例如 fs、path、http 等） 

​		自定义模块（用户创建的每个 .js 文件，都是自定义模块）

 	   第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载）

使用强大的 require() 方法，可以加载需要的内置模块、用户自定义模块、第三方模块进行使用

#### 模块作用域 

和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块 作用域。

 模块作用域的好处 ：防止了**全局变量污染**的问题

**module.exports 对象**

 在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。 外界用 require() 方法导入自定义模块时，得到的就是 module.exports 所指向的对象。

**注意：使用 require() 方法导入模块时，导入的结果，永远以 module.exports 指向的对象为准。**

为了简化向外共享成员的代码，Node 提供了 exports 对象。默认情况 下，**exports 和 module.exports 指向同一个对象**。最终共享的结果，还是以 module.exports 指向的对象为准。

**注意：为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports**

Node.js 遵循了 CommonJS 模块化规范，CommonJS 规定了模块的特性和各模块之间如何相互依赖。 

CommonJS 规定： 

​		① 每个模块内部，module 变量代表当前模块。 

​		② module 变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口。 

​		③ 加载某个模块，其实是加载该模块的 module.exports 属性。require() 方法用于加载模块。

###  npm与包 

#### 基本介绍

Node.js 中的第三方模块又叫做包。 第三方模块和包指的是同一个概念，只不过叫法不同。

npm, Inc. 公司提供了一个地址为 https://registry.npmjs.org/ 的服务器，来对外共享所有的包，我们可以从这个服务器上下载自己所需要的包。 

注意： 

​		从 https://www.npmjs.com/ 网站上搜索自己所需要的包 

​		从 https://registry.npmjs.org/ 服务器上下载自己需要的包

#### npm 初体验 

格式化时间的高级做法 

​		① 使用 npm 包管理工具，在项目中安装格式化时间的包 moment 

​		② 使用 require() 导入格式化时间的包 

​		③ 参考 moment 的官方 API 文档对时间进行格式化

```javascript
//导入moment包
const moment = require('moment')
//参考api文档使用moment的format方法对时间进行格式化
const dt = moment().format('YYYY-MM-DD')
console.log(dt)
```

npm的相关操作 

```javascript
npm install 包名 //安装指定的包
npm install 包名@x.x.x //安装指定版本的包
npm init -y  //在执行命令所处的目录中，快速创建package.json文件，
//该命令只能在英文的目录下成功运行！所以，项目文件夹的名称不要使用中文，不能出现空格。
npm install //一次性安装所有的依赖包
npm uninstall 包名 //删除指定的包
//查看当下的包镜像源（下载包的服务器地址）
npm config get registry
//将下载包的镜像源切换为淘宝镜像
npm config set registry=https://registry.npm.taobao.org/
//检查镜像源是否下载成功
npm config get registry
```

为了更方便的切换下包的镜像源，我们可以安装 nrm 这个小工具，利用 nrm 提供的终端命令，可以快速查看和切换下 包的镜像源

```javascript
//通过npm包管理器，将nrm安装为全局可用的工具
npm i nrm -g
//查看所有的镜像源
nrm ls
//将下包的镜像源切换为淘宝镜像
nrm use taobao
```

那些被安装到项目的 node_modules 目录中的包，都是项目包。 

项目包又分为两类，分别是： 

​		开发依赖包（被记录到 devDependencies 节点中的包，只在开发期间会用到） 

​		核心依赖包（被记录到 dependencies 节点中的包，在开发期间和项目上线之后都会用到）

```javascript
npm install -D //开发依赖包
npm install 包名  //核心依赖包
```

初次装包完成后，在项目文件夹下多一个叫做 node_modules 的文件夹和 package-lock.json 的配置文件。

 其中： 

​     node_modules 文件夹用来存放所有已安装到项目中的包。require() 导入第三方包时，就是从这个目录中查找并加载包。 

​     package- lock.json 配置文件用来记录 node_modules 目录下的每一个包的下载信息，例如包的名字、版本号、下载地址等。

​     package.json 文件中，有一个 dependencies 节点，专门用来记录您使用 npm install  命令安装了哪些包。

#### 包的分类

全局包

在执行 npm install 命令时，如果提供了 -g 参数，则会把包安装为全局包。 全局包会被安装到 C:\Users\用户目录\AppData\Roaming\npm\node_modules 目录下。

注意： 

​		① 只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。 

​		② 判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可

```javascript
npm install 包名 -g   //全局安装
npm uninstall 包名 -g  //卸载全局安装的包
```

 i5ting_toc

i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下：

```javascript
npm install -g i5ting_toc  //将其安装为全局包
i5ting_toc -f   要转换的md文件路径 -o  //转换md为html
```

#### 发布包

步骤：

​		1、注册npm账号

​		2、npm 账号注册完成后，可以在终端中执行 npm login 命令，依次输入用户名、密码、邮箱		后，即可登录成功。

​		3、将终端切换到包的根目录之后，运行 npm publish 命令，即可将包发布到 npm 上（注意：		包名不能雷同）。

运行 npm unpublish 包名 --force 命令，即可从 npm 删除已发布的包。

### 模块的加载机制

模块在第一次加载后会被缓存。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。 注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而提高模块的加载效率。

内置模块是由 Node.js 官方提供的模块，内置模块的加载优先级最高。

使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的路径标识符。在加载自定义模块时，如果没有指定 ./ 或 ../  这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。

## 3.Express

### 简介

Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。

 Express 的中文官网： http://www.expressjs.com.cn/

对于前端程序员来说，最常见的两种服务器，分别是： 

 		Web 网站服务器：专门对外提供 Web 网页资源的服务器。 

​		API 接口服务器：专门对外提供 API 接口的服务器。 使用 Express，我们可以方便、快速的创		建 Web 网站的服务器或 API 接口的服务器。

### 基本使用

#### 创建基本的web服务器

```javascript
// 导入 express
const express = require('express')
// 创建服务器实例
const app = express()
// 启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```

#### 监听 GET 请求和 POST请求

```javascript
//参数一：客户端请求的url地址
//参数二：请求对应的处理函数
app.get('请求url',function(req,res){})
```

```javascript
//参数一：客户端请求的url地址
//参数二：请求对应的处理函数
app.post('请求url',function(req,res){})
```

####  把内容响应给客户端 

通过 res.send() 方法，可以把处理好的内容，发送给客户端：

```javascript
app.get('/user',function(req,res){
    //向客户端发送json对象
    res.send({name:'zs',age:20,gender:'男'})
})
app.post('/user',function(req,res){
    //向客户端发送内容
    res.send('请求成功')
})
```

#### 获取 URL 中携带的查询参数

通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的参数：

```javascript
app.get('/user',function(req,res){
    //req.query默认是一个空对象
    //客户端通过？name=xx&age=20这种形式发送到服务器的参数
    //可以通过req.query.name  req.query.age获取到具体的参数
   console.log(req.query)
})
```

#### 获取 URL 中的动态参数

通过 req.params 对象，可以访问到 URL 中，通过 : 匹配到的动态参数：

```javascript
app.get('/user/:id',function(req,res){
    //req.params默认是一个空对象
    //里面存放着通过：动态匹配到的参数值
   console.log(req.params)
})
```

#### 托管静态资源

express.static()

 express 提供了一个非常好用的函数，叫做 express.static()，通过它，我们可以非常方便地创建一个静态资源服务器， 例如，通过如下代码就可以将 public 目录下的图片、CSS 文件、JavaScript 文件对外开放访问了：

```javascript
app.use(express.static('public'))//通过它可以访问 public 目录中的所有文件了：
```

注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。 因此，存放静态文件的目录名不会出现在 URL 中。

如果要托管多个静态资源目录，请多次调用 express.static() 函数：

```javascript
app.use(express.static('public'))

app.use(express.static('file'))
```

访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。

挂载路径前缀 

如果希望在托管的静态资源访问路径之前，挂载路径前缀，则可以使用如下的方式：

```javascript
app.use(‘/public’，express.static('public'))
```

就可以通过带有 /public 前缀地址来访问 public 目录中的文件了。

例如： http://localhost:3000/public/images/kitten.jpg

#### nodemon

nodemon（https://www.npmjs.com/package/nodemon） 这个工具，它能够监听项目文件 的变动，当代码被修改后，nodemon 会自动帮我们重启项目，极大方便了开发和调试

```javascript
npm install -g nodemon   //将 nodemon 安装为全局可用的工具
```

### Express路由

#### 基本介绍

广义上来讲，路由就是映射关系。

在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。

 Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：

```javascript
app.method(path,handler)
```

路由的基本使用

```javascript
const express = require('express')
//创建wenb服务器命名为app
const app = express()
// 挂载路由
app.get('/', (req, res) => {
  res.send('hello world.')
})
app.post('/', (req, res) => {
  res.send('Post Request.')
})
//启动web服务器
app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```

路由的匹配过程 

每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。 在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。

####  模块化路由

为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。 

将路由抽离为单独模块的步骤如下：

 		① 创建路由模块对应的 .js 文件 

​		② 调用 express.Router() 函数创建路由对象 

​		 ③ 向路由对象上挂载具体的路由 

​		 ④ 使用 module.exports 向外共享路由对象 

​		 ⑤ 使用 app.use() 函数注册路由模块

创建路由模块

```javascript
// 这是路由模块
// 1. 导入 express
const express = require('express')
// 2. 创建路由对象
const router = express.Router()
// 3. 挂载具体的路由
//这是查询用户信息的路由模块
router.get('/user/list', (req, res) => {
  res.send('Get user list.')
})
//这是添加用户信息的路由模块
router.post('/user/add', (req, res) => {
  res.send('Add new user.')
})
// 4. 向外导出路由对象
module.exports = router
```

注册路由模块（即在代码中引入路由模块）

```javascript
const express = require('express')
const app = express()
// 1. 导入路由模块
const router = require('./03.router')
// 2. 注册路由模块，并添加统一的前缀/api
app.use('/api', router)
// 注意： app.use() 函数的作用，就是来注册全局中间件
app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```

### Expess中间件

#### 基本介绍

中间件（Middleware ），特指业务流程的中间处理环节。

Express 中间件的调用流程 

当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。

Express 中间件的格式

 Express 的中间件，本质上就是一个 function 处理函数，Express 中间件的格式如下：

**注意：中间件函数的形参列表中，必须包含 next 参数。而路由处理函数中只包含 req 和 res。**

next 函数是实现多个中间件连续调用的关键，它表示把流转关系转交给下一个中间件或路由。

#### 基本使用

```javascript
// 这是定义全局中间件的简化形式
const mw=function(req,res,next){
     console.log('这是一个最简单的中间件函数')
  	next()
}
//全局生效的中间件
app.use(mw)
```

定义全局中间件的简化形式

```javascript
app.use((req, res, next) => {
  // 获取到请求到达服务器的时间
  const time = Date.now()
  // 为 req 对象，挂载自定义属性，从而把时间共享给后面的所有路由
  req.startTime = time
  next()
})
```

.中间件的作用 

多个中间件之间，共享同一份 req 和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或 res 对象添 加自定义的属性或方法，供下游的中间件或路由进行使用。

定义多个全局中间件 

可以使用 app.use() 连续定义多个全局中间件。客户端请求到达服务器之后，会按照中间件定义的先后顺序依次进行 调用，示例代码如下：

```javascript
const express = require('express')
const app = express()
// 定义第一个全局中间件
app.use((req, res, next) => {
  console.log('调用了第1个全局中间件')
  next()
})
// 定义第二个全局中间件
app.use((req, res, next) => {
  console.log('调用了第2个全局中间件')
  next()
})
// 定义一个路由
app.get('/user', (req, res) => {//请求这个路由会依次触发以上两个全局中间件
  res.send('User page.')
})
app.listen(80, () => {
  console.log('http://127.0.0.1')
})
```

局部生效的中间件 

不使用 app.use() 定义的中间件，叫做局部生效的中间件，示例代码如下：

```javascript
// 1. 定义中间件函数
const mw1 = (req, res, next) => {
  console.log('调用了局部生效的中间件')
  next()
}
// 2. 创建路由，mw1这个中间件只在以下这个路由中生效，这就是局部中间件
app.get('/', mw1, (req, res) => {
  res.send('Home page.')
})
//mw1这个中间件不会在以下这个路由中生效
app.get('/user', (req, res) => {
  res.send('User page.')
})
```

定义多个局部中间件 

可以在路由中，通过如下两种等价的方式，使用多个局部中间件：

```javascript
// 1. 定义中间件函数
const mw1 = (req, res, next) => {
  console.log('调用了第一个局部生效的中间件')
  next()
}
const mw2 = (req, res, next) => {
  console.log('调用了第二个局部生效的中间件')
  next()
}
// 2. 以下两个写法完全等价
app.get('/', [mw1, mw2], (req, res) => {
  res.send('Home page.')
})
app.get('/', mw1, mw2, (req, res) => {
  res.send('Home page.')
})
```

中间件的5个使用注意事项

 		① 一定要在路由之前注册中间件 

​		 ② 客户端发送过来的请求，可以连续调用多个中间件进行处理

​		 ③ 执行完中间件的业务代码之后，不要忘记调用 next() 函数 

​		 ④ 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码 

​		 ⑤ 连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象

#### 中间件的分类

Express 官方把常见的中间件用法，分成了 5 大类，分别是： 

​		① 应用级别的中间件 

​		② 路由级别的中间件 

​		③ 错误级别的中间件 

​		④ Express 内置的中间件 

​		⑤ 第三方的中间件

应用级别的中间件 

通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：

```javascript
//应用级别的中间件（全局中间件）
app.use((res,res)=>{
next()
})
//应用级别的中间件（局部中间件）
app.get('/',mw1,(res,res)=>{
res.send('home page')
})
```

路由级别的中间件

绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。它的用法和应用级别中间件没有任何区别。只不 过，应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上，代码示例如下：

```javascript
var app =express()
var router=express.Router()
//路由级别的中间件
router.use(function(req,res,next){
    console.log('time',Date.now())
    next()
})
app.use('/',router)
```

错误级别的中间件

错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。 

格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (err, req, res, next)。

**注意：错误级别的中间件， 必须注册在所有路由之后！**

```javascript
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()
// 1. 定义路由
app.get('/', (req, res) => {
  // 1.1 人为的制造错误
  throw new Error('服务器内部发生了错误！')
  res.send('Home page.')
})
// 2. 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃
app.use((err, req, res, next) => {
  console.log('发生了错误！' + err.message)
  res.send('Error：' + err.message)
})
// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

Express内置的中间件

 自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验： 

① express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性） 

② express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用） 

③ express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）

```javascript
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()
// 注意：除了错误级别的中间件，其他的中间件，必须在路由之前进行配置
// 通过 express.json() 这个中间件，解析表单中的 JSON 格式的数据
app.use(express.json())
// 通过 express.urlencoded() 这个中间件，来解析 表单中的 url-encoded 格式的数据
app.use(express.urlencoded({ extended: false }))
app.post('/user', (req, res) => {
  // 在服务器，可以使用 req.body 这个属性，来接收客户端发送过来的请求体数据
  // 默认情况下，如果不配置解析表单数据的中间件，则 req.body 默认等于 undefined
  console.log(req.body)
  res.send('ok')
})
app.post('/book', (req, res) => {
  // 在服务器端，可以通过 req,body 来获取 JSON 格式的表单数据和 url-encoded 格式的数据
  console.log(req.body)
  res.send('ok')
})
// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1')
})
```

第三方的中间件 

非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置 第三方中间件，从而提高项目的开发效率。 

例如：在 express@4.16.0 之前的版本中，经常使用 body-parser这个第三方中间件,来解析请求体数据。使用步骤如下：

 ① 运行 npm install body-parser 安装中间件

 ② 使用 require 导入中间件

 ③ 调用 app.use() 注册并使用中间件 注意：Express 内置的express.urlencoded中间件，就是基于body-parser这个第三方中间件进一步封装出来的。

### 使用Express写接口

#### 基本使用

创建基本的服务器

```javascript
// 导入 express
const express = require('express')
// 创建服务器实例
const app = express()
//导入路由模块
const router=require('./apiRouter')
// app.use({})
//把路由模块注册到app上
app.use('/api',router)
// 启动服务器
app.listen(80, () => {
  console.log('express server running at http://127.0.0.1')
})
```

```javascript
// 创建 API 路由模块  apiRouter
const express = require('express')
const router = express.Router()
// 在这里挂载对应的路由
router.get('/get', (req, res) => {
  // 通过 req.query 获取客户端通过查询字符串，发送到服务器的数据
  const query = req.query
  // 调用 res.send() 方法，向客户端响应处理的结果
  res.send({
    status: 0, // 0 表示处理成功，1 表示处理失败
    msg: 'GET 请求成功！', // 状态的描述
    data: query, // 需要响应给客户端的数据
  })
})

// 定义 POST 接口
router.post('/post', (req, res) => {
  // 通过 req.body 获取请求体中包含的 url-encoded 格式的数据
  const body = req.body
  // 调用 res.send() 方法，向客户端响应结果
  res.send({
    status: 0,
    msg: 'POST 请求成功！',
    data: body,
  })
})
// 定义 DELETE 接口
router.delete('/delete', (req, res) => {
  res.send({
    status: 0,
    msg: 'DELETE请求成功',
  })
})
module.exports = router
```

#### CORS 跨域资源共享

1、接口的跨域问题 

刚才编写的 GET 和 POST接口，存在一个很严重的问题：不支持跨域请求。

 解决接口跨域问题的方案主要有两种： 

① CORS（主流的解决方案，推荐使用） 

② JSONP（有缺陷的解决方案：只支持 GET 请求）

2、使用 cors 中间件解决跨域问题

cors 是 Express 的一个第三方中间件。通过安装和配置 cors 中间件，可以很方便地解决跨域问题。 使用步骤分为如下 3 步： 

① 运行 npm install cors 安装中间件 

② 使用 const cors = require('cors') 导入中间件 

③ 在路由之前调用 app.use(cors()) 配置中间件

####  JSONP 接口

## 4.数据库与身份认证

### 数据库的基本操作

### 在node.js中操作数据库

#### 配置mysql模块

 安装 mysql 模块

```javascript
npm install mysql
```

配置mysql模块

```javascript
//引入mysql模块
const mysql = require('mysql')
//配置数据库相关的信息
const db = mysql.createPool({
    host: '127.0.0.1',
    user: 'root',
    password: 'root',
    database: 'dormitory'
})
```

测试 mysql 模块能否正常工作

调用 db.query() 函数，指定要执行的 SQL 语句，通过回调函数拿到执行的结果：

```javascript
db.query('select * from student where name="小明"', (err, results) => {
  if (err) {
   return console.log(err.message)
  }
  else {
    console.log(results)
  }
})
```

#### 使用 mysql 模块操作 MySQL 数据库

查询 users 表中所有的数据

```javascript
const sqlStr = 'select * from users'
db.query(sqlStr, (err, results) => {
  // 查询数据失败
  if (err) return console.log(err.message)
  // 查询数据成功
  // 注意：如果执行的是 select 查询语句，则执行的结果是数组
  console.log(results)
}) 
```

向 users 表中，新增一条数据，其中 username 的值为 Spider-Man，password 的值为 pcc123

```javascript
const user = { username: 'Spider-Man', password: 'pcc123' }
// 定义待执行的 SQL 语句
const sqlStr = 'insert into users (username, password) values (?, ?)'
// 执行 SQL 语句
db.query(sqlStr, [user.username, user.password], (err, results) => {
  // 执行 SQL 语句失败了
  if (err) return console.log(err.message)
  // 成功了
  // 注意：如果执行的是 insert into 插入语句，则 results 是一个对象
  // 可以通过 affectedRows 属性，来判断是否插入数据成功
  if (results.affectedRows === 1) {
    console.log('插入数据成功!')
  }
}) 
```

插入数据的便捷方式

```javascript
 const user = { username: 'Spider-Man2', password: 'pcc4321' }
// 定义待执行的 SQL 语句
const sqlStr = 'insert into users set ?'
// 执行 SQL 语句
db.query(sqlStr, user, (err, results) => {
  if (err) return console.log(err.message)
  if (results.affectedRows === 1) {
    console.log('插入数据成功')
  }
}) 
```

更新用户的信息

```javascript
 const user = { id: 6, username: 'aaa', password: '000' }
// 定义 SQL 语句
const sqlStr = 'update users set username=?, password=? where id=?'
// 执行 SQL 语句
db.query(sqlStr, [user.username, user.password, user.id], (err, results) => {
  if (err) return console.log(err.message)
  // 注意：执行了 update 语句之后，执行的结果，也是一个对象，可以通过 affectedRows 判断是否更新成功
  if (results.affectedRows === 1) {
    console.log('更新成功')
  }
}) 
```

更新数据的便捷方式

```javascript
 const user = { id: 6, username: 'aaaa', password: '0000' }
// 定义 SQL 语句
const sqlStr = 'update users set ? where id=?'
// 执行 SQL 语句
db.query(sqlStr, [user, user.id], (err, results) => {
  if (err) return console.log(err.message)
  if (results.affectedRows === 1) {
    console.log('更新数据成功')
  }
}) 
```

 删除 id 为 5 的用户

```javascript
 const sqlStr = 'delete from users where id=?'
db.query(sqlStr, 5, (err, results) => {
  if (err) return console.log(err.message)
  // 注意：执行 delete 语句之后，结果也是一个对象，也会包含 affectedRows 属性
  if (results.affectedRows === 1) {
    console.log('删除数据成功')
  }
})
```

标记删除

```javascript
const sqlStr = 'update users set status=? where id=?'
db.query(sqlStr, [1, 6], (err, results) => {
  if (err) return console.log(err.message)
  if (results.affectedRows === 1) {
    console.log('标记删除成功')
}
```

### 前后端的身份认证

#### Web 开发模式

 目前主流的 Web 开发模式有两种，分别是： 

​		① 基于服务端渲染的传统 Web 开发模式 

​		② 基于前后端分离的新型 Web 开发模式

服务端渲染的优缺点 

优点： 

​		① 前端耗时少。因为服务器端负责动态生成 HTML 内容，浏览器只需要直接渲染页面即可。尤		其是移动端，更省电。 

​		② 有利于SEO。因为服务器端响应的是完整的 HTML 页面内容，所以爬虫更容易爬取获得信		息，更有利于 SEO。 

缺点： 

​		① 占用服务器端资源。即服务器端完成 HTML 页面内容的拼接，如果请求较多，会对服务器造		成一定的访问压力。 

​		② 不利于前后端分离，开发效率低。使用服务器端渲染，则无法进行分工合作，尤其对于前端		复杂度高的项目，不利于 项目高效开发。

前后端分离的优缺点 

优点： 

​		① 开发体验好。前端专注于 UI 页面的开发，后端专注于api 的开发，且前端有更多的选择性。 

​		② 用户体验好。Ajax 技术的广泛应用，极大的提高了用户的体验，可以轻松实现页面的局部刷		新。 

​		③ 减轻了服务器端的渲染压力。因为页面最终是在每个用户的浏览器中生成的。 

缺点： 

​		① 不利于 SEO。因为完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫对无法爬取页面		的有效信息。（解决方案：利用 Vue、React 等前端框架的 SSR （server side render）技术能		够很好的解决 SEO 问题！）

#### 身份认证

身份认证（Authentication）又称“身份验证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。

不同开发模式下的身份认证 

对于服务端渲染和前后端分离这两种开发模式来说，分别有着不同的身份认证方案： 

​		① 服务端渲染推荐使用 Session 认证机制 

​		② 前后端分离推荐使用 JWT 认证机制

Session 认证机制

Cookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用 于控制 Cookie 有效期、安全性、使用范围的可选属性组成。 不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。 

Cookie的几大特性： 

​		① 自动发送 

​		② 域名独立 

​		③ 过期时限 

​		④ 4KB 限制

Cookie 不具有安全性 

由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全 性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。

**注意：千万不要使用 Cookie 存储重要且隐私的数据！比如用户的身份信息、密码等**

#### 在 Express 中使用 Session 认证

```javascript
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()
// TODO_01：请配置 Session 中间件
const session = require('express-session')
//express-session 中间件安装成功后，需要通过 app.use() 来注册 session 中间件
app.use(
  session({
    secret: 'itheima',
    resave: false,
    saveUninitialized: true,
  })
)
// 托管静态页面
app.use(express.static('./pages'))
// 解析 POST 提交过来的表单数据
app.use(express.urlencoded({ extended: false }))

// 登录的 API 接口
app.post('/api/login', (req, res) => {
  // 判断用户提交的登录信息是否正确
  if (req.body.username !== 'admin' || req.body.password !== '000000') {
    return res.send({ status: 1, msg: '登录失败' })
  }
  // TODO_02：请将登录成功后的用户信息，保存到 Session 中
  // 注意：只有成功配置了 express-session 这个中间件之后，才能够通过 req 点出来 session 这个属性
  req.session.user = req.body // 用户的信息
  req.session.islogin = true // 用户的登录状态
  res.send({ status: 0, msg: '登录成功' })
})
// 获取用户姓名的接口
app.get('/api/username', (req, res) => {
  // TODO_03：请从 Session 中获取用户的名称，响应给客户端
  if (!req.session.islogin) {
    return res.send({ status: 1, msg: 'fail' })
  }
  res.send({
    status: 0,
    msg: 'success',
    username: req.session.user.username,
  })
})

// 退出登录的接口
app.post('/api/logout', (req, res) => {
  // TODO_04：清空 Session 信息
  req.session.destroy()
  res.send({
    status: 0,
    msg: '退出登录成功',
  })
})

// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(80, function () {
  console.log('Express server running at http://127.0.0.1:80')
})
```

#### JWT 认证机制

了解 Session 认证的局限性 

Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接 口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。 

注意： 

​		当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。 

​		当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证		机制。

JWT（英文全称：JSON Web Token）是目前最流行的跨域认证解决方案。

用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份

JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。

​	**Payload 部分才是真正的用户信息**，它是用户信息经过加密之后生成的字符串。 

​	 Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性。

```javascript
// 导入 express 模块
const express = require('express')
// 创建 express 的服务器实例
const app = express()

// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt
const jwt = require('jsonwebtoken')
const expressJWT = require('express-jwt')

// 允许跨域资源共享
const cors = require('cors')
app.use(cors())

// 解析 post 表单数据的中间件
const bodyParser = require('body-parser')
app.use(bodyParser.urlencoded({ extended: false }))

// TODO_02：定义 secret 密钥，建议将密钥命名为 secretKey
const secretKey = 'itheima No1 ^_^'

// TODO_04：注册将 JWT 字符串解析还原成 JSON 对象的中间件
// 注意：只要配置成功了 express-jwt 这个中间件，就可以把解析出来的用户信息，挂载到 req.user 属性上
app.use(expressJWT({ secret: secretKey }).unless({ path: [/^\/api\//] }))

// 登录接口
app.post('/api/login', function (req, res) {
  // 将 req.body 请求体中的数据，转存为 userinfo 常量
  const userinfo = req.body
  // 登录失败
  if (userinfo.username !== 'admin' || userinfo.password !== '000000') {
    return res.send({
      status: 400,
      message: '登录失败！',
    })
  }
  // 登录成功
  // TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端
  // 参数1：用户的信息对象
  // 参数2：加密的秘钥
  // 参数3：配置对象，可以配置当前 token 的有效期
  // 记住：千万不要把密码加密到 token 字符中
  const tokenStr = jwt.sign({ username: userinfo.username }, secretKey, { expiresIn: '30s' })
  res.send({
    status: 200,
    message: '登录成功！',
    token: tokenStr, // 要发送给客户端的 token 字符串
  })
})

// 这是一个有权限的 API 接口
app.get('/admin/getinfo', function (req, res) {
  // TODO_05：使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端
  console.log(req.user)
  res.send({
    status: 200,
    message: '获取用户信息成功！',
    data: req.user, // 要发送给客户端的用户信息
  })
})

// TODO_06：使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误
app.use((err, req, res, next) => {
  // 这次错误是由 token 解析失败导致的
  if (err.name === 'UnauthorizedError') {
    return res.send({
      status: 401,
      message: '无效的token',
    })
  }
  res.send({
    status: 500,
    message: '未知的错误',
  })
})
// 调用 app.listen 方法，指定端口号并启动web服务器
app.listen(8888, function () {
  console.log('Express server running at http://127.0.0.1:8888')
})
```

